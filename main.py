# Image to PDF Converter using PyQt6
# Author: Generated by Agent Mode
# Optimized and fixed by Gemini

from __future__ import annotations

import sys
import os
import tempfile
import traceback
import threading
import platform
import socket
import getpass
import hashlib
import io
from datetime import datetime
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Tuple, Optional

from PIL import Image
# Lazy import for less-used PIL modules
try:
    from PIL import ImageDraw, ImageFont, ImageOps
except ImportError:
    ImageDraw = None
    ImageFont = None
    ImageOps = None
from PyQt6.QtCore import Qt, QSize, QRect, QUrl, QThreadPool, QRunnable, pyqtSignal, QObject, QSettings, QEvent, QTimer
from PyQt6.QtGui import QIcon, QPixmap, QPainter, QColor, QPen, QPalette, QTransform, QAction, QDesktopServices, QImage, QImageReader, QFont, QFontDatabase
from PyQt6.QtWidgets import (
    QApplication,
    QMainWindow,
    QWidget,
    QListWidget,
    QListWidgetItem,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QFileDialog,
    QMessageBox,
    QAbstractItemView,
    QLabel,
    QFrame,
    QGroupBox,
    QFormLayout,
    QComboBox,
    QSpinBox,
    QDoubleSpinBox,
    QLineEdit,
    QStyleFactory,
    QToolBar,
    QMenu,
    QCheckBox,
    QProgressDialog,
    QSizePolicy,
    QScrollArea,
    QTabWidget,
    QDialog,
    QDialogButtonBox,
    QStyle,
)


ALLOWED_EXTS = {'.jpg', '.jpeg', '.png', '.bmp', '.tif', '.tiff'}

# Safe image loading helper that avoids Qt/libtiff TIFF metadata allocations
# and serializes Pillow decoding to prevent native crashes on Windows.
# Also only applies EXIF transpose for JPEG files to avoid libtiff code paths.
def _load_qimage_via_pillow(path: str, max_size: QSize | None = None) -> Optional[QImage]:
    try:
        from PIL import Image as _PILImage  # local alias to avoid confusion
        from PIL import ImageQt as _ImageQt

        # Work inside a global lock; some Pillow decoders (e.g., TIFF) are not thread-safe on Windows
        with PIL_LOCK:
            # Ensure we close the file-backed image as soon as possible
            with _PILImage.open(path) as _im:
                fmt = (_im.format or '').upper()
                img = _im
                # Apply EXIF orientation only for JPEG/JPG
                if fmt in ('JPEG', 'JPG'):
                    try:
                        if ImageOps is not None:
                            img = ImageOps.exif_transpose(img)
                    except Exception:
                        pass
                # Convert to display-friendly mode
                if img.mode not in ("RGB", "RGBA"):
                    img = img.convert("RGB")
                # Downscale early for thumbnails/previews to reduce memory
                if max_size is not None:
                    mw, mh = max(1, max_size.width()), max(1, max_size.height())
                    try:
                        # Pillow >=9 uses Resampling enum
                        resample = getattr(_PILImage, 'Resampling', _PILImage).LANCZOS
                        img.thumbnail((mw, mh), resample)
                    except Exception:
                        img.thumbnail((mw, mh))
                # Detach from the underlying file before leaving the context
                img = img.copy()

        qim_any = _ImageQt.ImageQt(img)
        # ImageQt returns a QImage-compatible object; ensure it's a QImage instance
        if isinstance(qim_any, QImage):
            return qim_any
        try:
            return QImage(qim_any)
        except Exception:
            # Fallback: convert via bytes buffer (PNG)
            buf = io.BytesIO()
            img.save(buf, format='PNG')
            data = buf.getvalue()
            qimg = QImage()
            qimg.loadFromData(data, 'PNG')
            return qimg if not qimg.isNull() else None
    except Exception:
        return None

# App metadata
APP_NAME = 'Image To PDF'
APP_VERSION = '1.2.0' # Version incremented

# Default URL icons (Tabler Icons CDN) used if no local files or Font Awesome
ICON_URL_DEFAULTS = {
    'add_images': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/photo.svg',
    'add_folder': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/folder.svg',
    'save_pdf': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/device-floppy.svg',
    'remove': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/trash.svg',
    'clear_list': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/broom.svg',
    'move_up': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/arrow-up.svg',
    'move_down': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/arrow-down.svg',
    'rotate_ccw': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/rotate-2.svg',
    'rotate_right': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/refresh.svg',
    'rotate_cw': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/refresh.svg',
    'theme': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/adjustments.svg',
    'tab_page': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/file.svg',
    'tab_quality': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/sliders.svg',
    'tab_info': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@3.6.0/icons/filled/info-circle.svg',
    'github': 'https://cdn.jsdelivr.net/npm/@tabler/icons-svg@latest/icons/brand-github.svg',
}

# Global lock to serialize Pillow decoder usage (some plugins are not thread-safe on Windows)
PIL_LOCK = threading.Lock()

PAGE_PRESETS_MM = {
    'A5': (148.0, 210.0),
    'A4': (210.0, 297.0),
    'A3': (297.0, 420.0),
    'Letter': (215.9, 279.4),
    'Legal': (215.9, 355.6),  # 8.5 x 14 in
}


@dataclass
class ExportSettings:
    page_mm: Tuple[float, float]  # width, height in mm (before orientation)
    orientation: str  # 'Portrait' | 'Landscape'
    margin_mm: float  # uniform margins in mm
    dpi: int
    fit_mode: str  # 'Fit' | 'Fill' | 'Center'
    quality: int  # 1-95
    title: str = ''
    author: str = ''
    subject: str = ''
    keywords: str = ''
    user_password: str = ''
    owner_password: str = ''
    page_numbers: bool = False
    page_number_pos: str = 'Bottom-Center'
    page_number_size_pt: int = 12


def is_image_file(path: Path) -> bool:
    return path.is_file() and path.suffix.lower() in ALLOWED_EXTS


class ImageListWidget(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)
        # Gallery-like icon grid for better use of space
        self.setViewMode(QListWidget.ViewMode.IconMode)
        self.setWrapping(True)
        try:
            self.setResizeMode(QListWidget.ResizeMode.Adjust)
        except AttributeError: # QAbstractItemView in older versions
            self.setResizeMode(QAbstractItemView.ResizeMode.Adjust)
        self.setIconSize(QSize(140, 140))
        self.setGridSize(QSize(160, 180))
        self.setAcceptDrops(True)
        self.setSpacing(8)
        self.setUniformItemSizes(True)
        self.setWordWrap(True)


    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            super().dragEnterEvent(event)

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            super().dragMoveEvent(event)

    def dropEvent(self, event):
        if event.mimeData().hasUrls():
            paths: List[Path] = []
            for url in event.mimeData().urls():
                local = Path(url.toLocalFile())
                if local.is_dir():
                    paths.extend(p for p in local.rglob('*') if is_image_file(p))
                elif is_image_file(local):
                    paths.append(local)
            if paths:
                self.window().add_images(paths)  # type: ignore[attr-defined]
            event.acceptProposedAction()
        else:
            super().dropEvent(event)


class _ThumbSignals(QObject):
    resultReady = pyqtSignal(str, QImage)


class _ThumbTask(QRunnable):
    def __init__(self, path: str, max_size: QSize, signals: _ThumbSignals):
        super().__init__()
        self.path = path
        self.max_size = max_size
        self.signals = signals

    def run(self):
        # Prefer Qt's QImageReader first (more robust for thumbnails on Windows)
        try:
            reader = QImageReader(self.path)
            reader.setAutoTransform(True)
            if self.max_size is not None:
                # Scale during decode while PRESERVING aspect ratio
                try:
                    orig_sz = reader.size()
                    if orig_sz.isValid():
                        mw, mh = self.max_size.width(), self.max_size.height()
                        s = min(max(1, mw) / max(1, orig_sz.width()), max(1, mh) / max(1, orig_sz.height()))
                        sw = max(1, int(orig_sz.width() * s))
                        sh = max(1, int(orig_sz.height() * s))
                        reader.setScaledSize(QSize(sw, sh))
                except Exception:
                    pass
            img = reader.read()
            if not img.isNull():
                self.signals.resultReady.emit(self.path, img)
                return
        except Exception:
            pass
        # Fallbacks
        try:
            img = QImage(self.path)
            if not img.isNull():
                self.signals.resultReady.emit(self.path, img)
                return
        except Exception:
            pass
        try:
            # Last resort: use Pillow path (serialized and hardened)
            qimg = _load_qimage_via_pillow(self.path, self.max_size)
            if qimg is not None and not qimg.isNull():
                self.signals.resultReady.emit(self.path, qimg)
        except Exception:
            pass


class MainWindow(QMainWindow):
    ROTATION_ROLE = Qt.ItemDataRole.UserRole + 1

    def __init__(self):
        super().__init__()
        self.setWindowTitle('Image to PDF Converter - Pro')
        # Set window icon
        try:
            icon = QApplication.windowIcon()
            if not icon.isNull():
                self.setWindowIcon(icon)
        except Exception:
            pass
        self.resize(1280, 800)
        self.setMinimumSize(1000, 600)
        self.statusBar().showMessage('Ready • Drop files or folders to begin')

        central = QWidget()
        self.setCentralWidget(central)

        main_layout = QHBoxLayout(central)

        # Left: image list
        self.list_widget = ImageListWidget()
        main_layout.addWidget(self.list_widget, stretch=1)
        self.list_widget.currentItemChanged.connect(self.update_preview)
        self.list_widget.itemSelectionChanged.connect(self.update_preview)
        self.list_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.list_widget.customContextMenuRequested.connect(self.on_list_context_menu)

        # Middle: preview
        preview_layout = QVBoxLayout()
        main_layout.addLayout(preview_layout, stretch=1)
        # Scrollable preview with zoom controls
        self.preview_label = QLabel('Preview')
        self.preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.preview_label.setStyleSheet('background: #fafafa; border: 1px solid #ddd;')
        self.preview_area = QScrollArea()
        self.preview_area.setWidget(self.preview_label)
        self.preview_area.setWidgetResizable(False)
        self.preview_area.viewport().installEventFilter(self)
        preview_layout.addWidget(self.preview_area)
        # Zoom controls
        zoom_bar = QHBoxLayout()
        self.zoom_fit_cb = QCheckBox('Fit')
        self.zoom_fit_cb.setChecked(True)
        self.zoom_fit_cb.toggled.connect(self.on_zoom_fit_toggled)
        btn_zoom_out = QPushButton('−')
        btn_zoom_out.setToolTip('Zoom out (Mouse Wheel Down)')
        btn_zoom_out.clicked.connect(lambda: self.on_zoom_step(0.9))
        btn_zoom_reset = QPushButton('100%')
        btn_zoom_reset.setToolTip('Reset zoom to 100%')
        btn_zoom_reset.clicked.connect(self.on_zoom_reset)
        btn_zoom_in = QPushButton('+')
        btn_zoom_in.setToolTip('Zoom in (Mouse Wheel Up)')
        btn_zoom_in.clicked.connect(lambda: self.on_zoom_step(1.1))
        self.zoom_label = QLabel('100%')
        zoom_bar.addWidget(self.zoom_fit_cb)
        zoom_bar.addStretch(1)
        zoom_bar.addWidget(btn_zoom_out)
        zoom_bar.addWidget(btn_zoom_reset)
        zoom_bar.addWidget(btn_zoom_in)
        zoom_bar.addStretch(1)
        zoom_bar.addWidget(self.zoom_label)
        preview_layout.addLayout(zoom_bar)

        # Right: controls (in a fixed-width side panel to avoid over-expansion in fullscreen)
        right_panel = QWidget()
        controls = QVBoxLayout(right_panel)
        right_panel.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Preferred)
        right_panel.setMaximumWidth(420)
        main_layout.addWidget(right_panel)

        self.info_label = QLabel('Add images or drop files/folders here\nDrag to reorder • Ctrl+O to add files')
        self.info_label.setWordWrap(True)
        self.info_label.setStyleSheet('padding: 12px; background: rgba(33, 150, 243, 0.1); border-radius: 8px; border-left: 4px solid #2196F3; font-size: 12px;')
        controls.addWidget(self.info_label)

        theme_layout = QHBoxLayout()
        theme_label = QLabel('Theme')
        self.theme_combo = QComboBox()
        self.theme_combo.addItems(['Light', 'Dark'])
        self.theme_combo.setCurrentText('Dark')
        self.theme_combo.currentTextChanged.connect(self.on_theme_changed)
        theme_layout.addWidget(theme_label)
        theme_layout.addWidget(self.theme_combo)
        controls.addLayout(theme_layout)

        btn_add = QPushButton('Add Images…')
        btn_add.clicked.connect(self.on_add_images)
        controls.addWidget(btn_add)

        btn_add_folder = QPushButton('Add Folder…')
        btn_add_folder.clicked.connect(self.on_add_folder)
        controls.addWidget(btn_add_folder)

        btn_remove = QPushButton('Remove Selected')
        btn_remove.clicked.connect(self.on_remove_selected)
        controls.addWidget(btn_remove)

        btn_clear = QPushButton('Clear List')
        btn_clear.clicked.connect(self.on_clear_list)
        controls.addWidget(btn_clear)


        btn_dedupe = QPushButton('Remove Duplicates')
        btn_dedupe.setToolTip('Remove duplicates by content and exact path')
        btn_dedupe.clicked.connect(self.on_remove_duplicates)
        controls.addWidget(btn_dedupe)


        # Rotate
        rotate_layout = QHBoxLayout()
        btn_rot_l = QPushButton('Rotate ⟲')
        btn_rot_l.clicked.connect(lambda: self.on_rotate(-90))
        rotate_layout.addWidget(btn_rot_l)
        btn_rot_r = QPushButton('Rotate ⟳')
        btn_rot_r.clicked.connect(lambda: self.on_rotate(90))
        rotate_layout.addWidget(btn_rot_r)
        controls.addLayout(rotate_layout)

        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        controls.addWidget(line)

        # Export settings with tabs for better organization
        settings_tabs = QTabWidget()
        settings_tabs.setDocumentMode(True)
        
        # TAB 1: Page Setup
        page_tab = QWidget()
        page_form = QFormLayout(page_tab)
        page_form.setFieldGrowthPolicy(QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow)
        page_form.setContentsMargins(12, 12, 12, 12)
        page_form.setSpacing(10)

        self.page_preset = QComboBox()
        self.page_preset.addItems(['A5', 'A4', 'A3', 'Letter', 'Legal', 'Custom'])
        self.page_preset.setCurrentText('A4')
        self.page_preset.setToolTip('Select a predefined page size, or choose Custom to set your own width/height.')
        self.page_preset.currentTextChanged.connect(self.on_page_preset_changed)
        page_form.addRow('Page Size', self.page_preset)

        # Unit selector for custom size and margins
        self.unit_combo = QComboBox()
        self.unit_combo.addItems(['mm', 'cm'])
        self.unit_combo.setCurrentText('mm')
        self.unit_combo.setToolTip('Units for custom width/height and margins.')
        self.unit_combo.currentTextChanged.connect(self.on_unit_changed)

        self.custom_w = QDoubleSpinBox()
        self.custom_w.setRange(10.0, 2000.0)
        self.custom_w.setValue(210.0)
        self.custom_w.setSuffix(' mm')
        self.custom_w.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        self.custom_h = QDoubleSpinBox()
        self.custom_h.setRange(10.0, 2000.0)
        self.custom_h.setValue(297.0)
        self.custom_h.setSuffix(' mm')
        self.custom_h.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        wh_layout = QHBoxLayout()
        wh_layout.setContentsMargins(0, 0, 0, 0)
        wh_layout.setSpacing(8)
        wh_layout.addWidget(self.custom_w)
        wh_layout.addWidget(self.custom_h)
        self.unit_combo.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        wh_layout.addWidget(self.unit_combo)
        wh_layout.addStretch(1)
        page_form.addRow('Custom (W×H)', self._wrap_layout(wh_layout))

        self.orientation = QComboBox()
        self.orientation.addItems(['Portrait', 'Landscape'])
        self.orientation.currentTextChanged.connect(self.update_preview)
        page_form.addRow('Orientation', self.orientation)

        self.margin = QDoubleSpinBox()
        self.margin.setRange(0.0, 100.0)
        self.margin.setValue(0.0)
        self.margin.setSuffix(' mm')
        self.margin.setToolTip('Uniform page margins. Set to 0 for edge-to-edge output.')
        self.margin.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        self.margin.valueChanged.connect(self.update_preview)
        page_form.addRow('Margins', self.margin)

        idx_page = settings_tabs.addTab(page_tab, 'Page')
        try:
            settings_tabs.setTabIcon(idx_page, self._icon_for(['tab_page','page'], QStyle.StandardPixmap.SP_FileIcon, fa_code=0xf15b))
        except Exception:
            pass

        # TAB 2: Quality
        quality_tab = QWidget()
        quality_form = QFormLayout(quality_tab)
        quality_form.setFieldGrowthPolicy(QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow)
        quality_form.setContentsMargins(12, 12, 12, 12)
        quality_form.setSpacing(10)

        self.dpi_spin = QSpinBox()
        self.dpi_spin.setRange(72, 1200)
        self.dpi_spin.setValue(300)
        self.dpi_spin.setToolTip('Rendering resolution (dots per inch). Higher = larger PDF and sharper output. 300 DPI is a good balance.')
        self.dpi_spin.valueChanged.connect(self.update_preview)
        quality_form.addRow('DPI', self.dpi_spin)

        self.fit_mode = QComboBox()
        self.fit_mode.addItems(['Fit', 'Fill', 'Center'])
        self.fit_mode.setCurrentText('Fit')
        self.fit_mode.setToolTip('Fit: contain inside margins. Fill: cover and crop. Center: no scaling, may clip.')
        self.fit_mode.currentTextChanged.connect(self.update_preview)
        quality_form.addRow('Fit Mode', self.fit_mode)

        self.quality_spin = QSpinBox()
        self.quality_spin.setRange(1, 100)
        self.quality_spin.setValue(95)
        self.quality_spin.setToolTip('JPEG quality used when embedding pages. Lower = smaller file, higher = better quality.')
        quality_form.addRow('JPEG Quality', self.quality_spin)

        # Page numbering
        self.page_numbers_cb = QCheckBox('Enable page numbers')
        self.page_numbers_cb.toggled.connect(self.update_preview)
        quality_form.addRow('Page Numbers', self.page_numbers_cb)
        
        self.page_num_pos = QComboBox()
        self.page_num_pos.addItems(['Top-Left','Top-Center','Top-Right','Bottom-Left','Bottom-Center','Bottom-Right'])
        self.page_num_pos.currentTextChanged.connect(self.update_preview)
        quality_form.addRow('   Position', self.page_num_pos)
        
        self.page_num_size = QSpinBox()
        self.page_num_size.setRange(6, 72)
        self.page_num_size.setValue(12)
        self.page_num_size.valueChanged.connect(self.update_preview)
        quality_form.addRow('   Size (pt)', self.page_num_size)

        idx_quality = settings_tabs.addTab(quality_tab, 'Quality')
        try:
            settings_tabs.setTabIcon(idx_quality, self._icon_for(['tab_quality','quality'], QStyle.StandardPixmap.SP_DialogApplyButton, fa_code=0xf1de))
        except Exception:
            pass

        # TAB 3: Metadata & Security
        meta_tab = QWidget()
        meta_form = QFormLayout(meta_tab)
        meta_form.setFieldGrowthPolicy(QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow)
        meta_form.setContentsMargins(12, 12, 12, 12)
        meta_form.setSpacing(10)

        self.title_edit = QLineEdit()
        self.title_edit.setPlaceholderText('Document title')
        meta_form.addRow('Title', self.title_edit)
        
        self.author_edit = QLineEdit()
        self.author_edit.setPlaceholderText('Author name')
        meta_form.addRow('Author', self.author_edit)
        
        self.subject_edit = QLineEdit()
        self.subject_edit.setPlaceholderText('Subject or topic')
        meta_form.addRow('Subject', self.subject_edit)
        
        self.keywords_edit = QLineEdit()
        self.keywords_edit.setPlaceholderText('Comma-separated keywords')
        meta_form.addRow('Keywords', self.keywords_edit)

        meta_form.addRow(QLabel())  # Spacer
        
        self.user_pwd_edit = QLineEdit()
        self.user_pwd_edit.setEchoMode(QLineEdit.EchoMode.Password)
        self.user_pwd_edit.setPlaceholderText('Leave empty for no password')
        meta_form.addRow('User Password', self.user_pwd_edit)
        
        self.owner_pwd_edit = QLineEdit()
        self.owner_pwd_edit.setEchoMode(QLineEdit.EchoMode.Password)
        self.owner_pwd_edit.setPlaceholderText('Leave empty for no password')
        meta_form.addRow('Owner Password', self.owner_pwd_edit)

        idx_info = settings_tabs.addTab(meta_tab, 'Info')
        try:
            settings_tabs.setTabIcon(idx_info, self._icon_for(['tab_info','info'], QStyle.StandardPixmap.SP_MessageBoxInformation, fa_code=0xf05a))
        except Exception:
            pass

        controls.addWidget(settings_tabs)

        # Toolbar (top)
        tb = QToolBar('Main')
        tb.setMovable(False)
        # Ensure icons are visible and sized
        try:
            tb.setIconSize(QSize(20, 20))
            tb.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)
        except Exception:
            pass
        self.addToolBar(tb)

        # Helper to pick icon with FA -> local file -> URL map -> system fallback
        def icon_for(keys: Iterable[str], style_px: QStyle.StandardPixmap, fa_code: Optional[int] = None) -> QIcon:
            dbg = os.getenv('ICON_DEBUG')
            used = ''
            # Font Awesome first
            if fa_code is not None and getattr(self, '_fa_family', ''):
                # Use current theme's text color for the icon
                color = self.palette().color(QPalette.ColorRole.WindowText)
                ic = _fa_icon(self._fa_family, fa_code, color=color)
                if not ic.isNull():
                    used = f'fa code=0x{fa_code:x}'
                    if dbg: print(f"[icon] {'/'.join(keys)} <- {used}", file=sys.stderr)
                    return ic
            # URL map (prefer public icons if provided)
            for k in keys:
                url = self._icon_urls.get(k) if isinstance(self._icon_urls, dict) else None
                if url:
                    ic = _icon_from_url(url, self._base_dir / 'icon_cache')
                    if not ic.isNull():
                        used = f'url {url}'
                        if dbg: print(f"[icon] {'/'.join(keys)} <- {used}", file=sys.stderr)
                        return ic
                    elif dbg: print(f"[icon] {'/'.join(keys)} url failed: {url}", file=sys.stderr)
            # Local files
            ic = _load_custom_icon(self._base_dir, keys)
            if not ic.isNull():
                used = 'local file'
                if dbg: print(f"[icon] {'/'.join(keys)} <- {used}", file=sys.stderr)
                return ic
            # System fallback
            if dbg: print(f"[icon] {'/'.join(keys)} <- system fallback", file=sys.stderr)
            return self.style().standardIcon(style_px)

        self._icon_for = icon_for
        act_add = QAction('Add Images', self)
        try:
            act_add.setIcon(self._icon_for(['add_images','add','open'], QStyle.StandardPixmap.SP_DialogOpenButton, fa_code=0xf03e))
        except Exception:
            pass
        act_add.setShortcut('Ctrl+O')
        act_add.triggered.connect(self.on_add_images)
        tb.addAction(act_add)
        act_add_folder = QAction('Add Folder', self)
        try:
            act_add_folder.setIcon(self._icon_for(['add_folder','folder_open'], QStyle.StandardPixmap.SP_DirOpenIcon, fa_code=0xf07c))
        except Exception:
            pass
        act_add_folder.setShortcut('Ctrl+Shift+O')
        act_add_folder.triggered.connect(self.on_add_folder)
        tb.addAction(act_add_folder)
        tb.addSeparator()
        self.act_save = QAction('Save PDF', self)
        try:
            self.act_save.setIcon(self._icon_for(['save_pdf','save'], QStyle.StandardPixmap.SP_DialogSaveButton, fa_code=0xf0c7))
        except Exception:
            pass
        self.act_save.setShortcut('Ctrl+S')
        self.act_save.triggered.connect(self.on_save_pdf)
        tb.addAction(self.act_save)
        tb.addSeparator()
        act_rm = QAction('Remove Selected', self)
        try:
            act_rm.setIcon(self._icon_for(['remove','trash'], QStyle.StandardPixmap.SP_TrashIcon, fa_code=0xf1f8))
        except Exception:
            pass
        act_rm.setShortcut('Delete')
        act_rm.triggered.connect(self.on_remove_selected)
        tb.addAction(act_rm)
        act_clear = QAction('Clear List', self)
        try:
            act_clear.setIcon(self._icon_for(['clear_list','clear'], QStyle.StandardPixmap.SP_DialogResetButton, fa_code=0xf51a))
        except Exception:
            pass
        act_clear.setShortcut('Ctrl+L')
        act_clear.triggered.connect(self.on_clear_list)
        tb.addAction(act_clear)
        tb.addSeparator()
        act_up = QAction('Move Up', self)
        try:
            act_up.setIcon(self._icon_for(['move_up','arrow_up'], QStyle.StandardPixmap.SP_ArrowUp, fa_code=0xf062))
        except Exception:
            pass
        act_up.setShortcut('Alt+Up')
        act_up.triggered.connect(self.on_move_up)
        tb.addAction(act_up)
        act_down = QAction('Move Down', self)
        try:
            act_down.setIcon(self._icon_for(['move_down','arrow_down'], QStyle.StandardPixmap.SP_ArrowDown, fa_code=0xf063))
        except Exception:
            pass
        act_down.setShortcut('Alt+Down')
        act_down.triggered.connect(self.on_move_down)
        tb.addAction(act_down)
        tb.addSeparator()
        act_rot_l = QAction('Rotate ⟲', self)
        try:
            act_rot_l.setIcon(self._icon_for(['rotate_ccw','rotate_left'], QStyle.StandardPixmap.SP_BrowserReload, fa_code=0xf0e2))
        except Exception:
            pass
        act_rot_l.setShortcut('Ctrl+[')
        act_rot_l.triggered.connect(lambda: self.on_rotate(-90))
        tb.addAction(act_rot_l)
        act_rot_r = QAction('Rotate ⟳', self)
        try:
            act_rot_r.setIcon(self._icon_for(['rotate_cw','rotate_right'], QStyle.StandardPixmap.SP_BrowserReload, fa_code=0xf01e))
        except Exception:
            pass
        act_rot_r.setShortcut('Ctrl+]')
        act_rot_r.triggered.connect(lambda: self.on_rotate(90))
        tb.addAction(act_rot_r)
        tb.addSeparator()
        act_theme = QAction('Toggle Theme', self)
        try:
            act_theme.setIcon(self._icon_for(['theme','appearance'], QStyle.StandardPixmap.SP_DesktopIcon, fa_code=0xf042))
        except Exception:
            pass
        act_theme.setShortcut('Ctrl+T')
        act_theme.triggered.connect(self.on_toggle_theme)
        tb.addAction(act_theme)
        tb.addSeparator()
        act_intro = QAction('Intro', self)
        act_intro.setShortcut('F1')
        act_intro.triggered.connect(self.on_show_intro)
        tb.addAction(act_intro)

        controls.addStretch(1)

        self.btn_save = QPushButton('Save as PDF…')
        self.btn_save.setDefault(True)
        self.btn_save.clicked.connect(self.on_save_pdf)
        controls.addWidget(self.btn_save)

        # Donation button
        btn_donate = QPushButton('DONATION')
        # Bold text for prominence
        try:
            f = btn_donate.font()
            f.setBold(True)
            btn_donate.setFont(f)
        except Exception:
            # Fallback via stylesheet if needed
            btn_donate.setStyleSheet(btn_donate.styleSheet() + ' font-weight: 700;')
        btn_donate.clicked.connect(lambda: QDesktopServices.openUrl(QUrl('https://pay-coffee.vercel.app/')))
        controls.addWidget(btn_donate)

        # GitHub and Credit layout
        bottom_links_layout = QHBoxLayout()

        # GitHub Button
        btn_github = QPushButton(' GitHub')
        btn_github.setToolTip('View the source code and latest updates on GitHub')
        try:
            # Font Awesome code for GitHub is 0xf09b
            btn_github.setIcon(self._icon_for(['github', 'source-code'], QStyle.StandardPixmap.SP_CommandLink, fa_code=0xf09b))
        except Exception:
            pass
        btn_github.clicked.connect(lambda: QDesktopServices.openUrl(QUrl('https://github.com/ozo-design/Image-To-PDF-Converter-PRO')))
        bottom_links_layout.addWidget(btn_github)

        bottom_links_layout.addStretch(1)

        # Credit Label
        credit = QLabel('<a href="https://pay-coffee.vercel.app/">Created by OZO. Designer</a>')
        credit.setOpenExternalLinks(True)
        credit.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        bottom_links_layout.addWidget(credit)

        controls.addLayout(bottom_links_layout)

        # Base dir for resources/icons
        self._base_dir = Path(__file__).resolve().parent
        # Optional URL icon mapping
        self._icon_urls = _load_icon_url_map(self._base_dir)
        # Initialize
        self._thumb_pool = QThreadPool.globalInstance()
        # Increase thread count for faster thumbnail generation (2-4 workers)
        try:
            self._thumb_pool.setMaxThreadCount(min(4, os.cpu_count() or 2))
        except Exception:
            pass
        self._thumb_signals = _ThumbSignals()
        self._thumb_signals.resultReady.connect(self._on_thumb_ready)
        self._thumb_pending: set[str] = set()
        # In-memory caches
        self._thumb_cache: dict[tuple[str,int,int], QIcon] = {}
        self._last_preview_key: tuple | None = None
        # Debounced preview renderer
        self._preview_timer = QTimer(self)
        self._preview_timer.setSingleShot(True)
        self._preview_timer.timeout.connect(self._render_preview)

        # Settings persistence
        self._qsettings = QSettings('OZO', 'ImageToPDF')
        self.last_dir: Path | None = None
        self._load_settings()

        self._apply_theme(self.theme_combo.currentText())
        self.on_page_preset_changed(self.page_preset.currentText())
        self._update_actions_enabled()
        self._update_info()
        # Preview zoom state
        self._last_preview: QPixmap | None = None
        self.preview_zoom: float = 1.0
        self.preview_fit: bool = True
        self.update_preview()
        # Show intro on first run
        try:
            self._maybe_show_intro()
        except Exception:
            pass

    def _wrap_layout(self, layout: QHBoxLayout) -> QWidget:
        w = QWidget()
        w.setLayout(layout)
        # Ensure row widget expands horizontally but keeps fixed height
        w.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        return w

    # Event filter to support Ctrl+Wheel zoom and fit-on-resize
    def eventFilter(self, obj, event):
        try:
            if obj == self.preview_area.viewport():
                if event.type() == QEvent.Type.Wheel:
                    # Mouse wheel zoom (no modifier needed)
                    delta = event.angleDelta().y()
                    if delta:
                        # One notch (120) ~= 10% zoom change
                        factor = pow(1.1, float(delta) / 120.0)
                        self.on_zoom_step(factor)
                        return True
                elif event.type() == QEvent.Type.Resize:
                    if self.preview_fit:
                        self._apply_preview_zoom()
        except Exception:
            pass
        return super().eventFilter(obj, event)

    # ------- UI Actions -------
    def _dialog_start_dir(self) -> str:
        return str(self.last_dir or Path.home())

    def on_add_images(self):
        files, _ = QFileDialog.getOpenFileNames(
            self,
            'Select images',
            self._dialog_start_dir(),
            'Images (*.png *.jpg *.jpeg *.bmp *.tif *.tiff)'
        )
        if files:
            try:
                self.last_dir = Path(files[0]).parent
            except Exception:
                pass
            self.add_images(Path(p) for p in files)
            self._save_settings()

    def on_add_folder(self):
        directory = QFileDialog.getExistingDirectory(self, 'Select folder', self._dialog_start_dir())
        if directory:
            folder = Path(directory)
            self.last_dir = folder
            self._save_settings()
            images = [p for p in folder.rglob('*') if is_image_file(p)]
            if images:
                self.add_images(images)
            else:
                QMessageBox.information(self, 'No images', 'No supported images found in the selected folder.')

    def on_remove_selected(self):
        for item in self.list_widget.selectedItems():
            self.list_widget.takeItem(self.list_widget.row(item))
        # ensure a current item exists if list not empty
        if self.list_widget.count() and self.list_widget.currentRow() == -1:
            self.list_widget.setCurrentRow(0)
        self._update_actions_enabled()
        self._update_info()
        self.update_preview()

    def on_move_up(self):
        rows = sorted([self.list_widget.row(i) for i in self.list_widget.selectedItems()])
        for row in rows:
            if row > 0:
                item = self.list_widget.takeItem(row)
                self.list_widget.insertItem(row - 1, item)
                item.setSelected(True)

    def on_move_down(self):
        rows = sorted([self.list_widget.row(i) for i in self.list_widget.selectedItems()], reverse=True)
        for row in rows:
            if row < self.list_widget.count() - 1:
                item = self.list_widget.takeItem(row)
                self.list_widget.insertItem(row + 1, item)
                item.setSelected(True)



    def on_remove_duplicates(self):
        total = self.list_widget.count()
        if total <= 1:
            return

        progress = QProgressDialog('Scanning for duplicate images...', 'Cancel', 0, total * 2, self)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setAutoClose(True)
        progress.setValue(0)
        
        try:
            items = [(i, self.list_widget.item(i)) for i in range(total)]
            paths = []
            for idx, it in items:
                try:
                    p = Path(it.data(Qt.ItemDataRole.UserRole))
                    paths.append((idx, it, p))
                except Exception: pass

            size_groups: dict[int, list[tuple[int, QListWidgetItem, Path]]] = {}
            for i, (idx, it, p) in enumerate(paths):
                progress.setValue(i)
                QApplication.processEvents()
                if progress.wasCanceled(): return
                try: sz = p.stat().st_size
                except Exception: sz = -1
                size_groups.setdefault(sz, []).append((idx, it, p))

            to_remove_idx: set[int] = set()
            processed_files = total
            
            for sz, group in size_groups.items():
                if progress.wasCanceled(): break
                if len(group) <= 1: continue

                bucket: dict[str, list[tuple[int, QListWidgetItem, Path]]] = {}
                for idx, it, p in group:
                    progress.setValue(processed_files)
                    QApplication.processEvents()
                    if progress.wasCanceled(): break
                    try:
                        h = hashlib.sha1()
                        with p.open('rb') as f: h.update(f.read(1024 * 1024))
                        ph = f"{sz}:{h.hexdigest()}"
                    except Exception: ph = f"{sz}:{str(p)}"
                    bucket.setdefault(ph, []).append((idx, it, p))
                    processed_files += 1

                for ph, group2 in bucket.items():
                    if len(group2) <= 1: continue
                    fulls: dict[str, tuple[int, QListWidgetItem, Path]] = {}
                    for idx, it, p in group2:
                        if progress.wasCanceled(): break
                        try:
                            h2 = hashlib.sha1()
                            with p.open('rb') as f:
                                for chunk in iter(lambda: f.read(4 * 1024 * 1024), b''):
                                    h2.update(chunk)
                            key = h2.hexdigest()
                        except Exception: key = f"ERR:{str(p)}"
                        if key in fulls:
                            to_remove_idx.add(idx)
                        else:
                            fulls[key] = (idx, it, p)
            
            seen_paths: set[str] = set()
            for idx, it, p in paths:
                sp = str(p)
                if sp in seen_paths: to_remove_idx.add(idx)
                else: seen_paths.add(sp)
            
            removed = 0
            if not progress.wasCanceled():
                for idx in sorted(to_remove_idx, reverse=True):
                    self.list_widget.takeItem(idx)
                    removed += 1
                if removed:
                    self.statusBar().showMessage(f'Removed {removed} duplicate(s)', 4000)
        finally:
            progress.close()

        if self.list_widget.count() and self.list_widget.currentRow() == -1:
            self.list_widget.setCurrentRow(0)
        self._update_info()
        self.update_preview()

    def on_rotate(self, delta_deg: int):
        for it in self.list_widget.selectedItems():
            curr = it.data(self.ROTATION_ROLE) or 0
            curr = (curr + delta_deg) % 360
            it.setData(self.ROTATION_ROLE, curr)
            # indicate in label
            name = Path(it.data(Qt.ItemDataRole.UserRole)).name
            it.setText(f"{name}  ({curr}°)")
        self.update_preview()

    def on_page_preset_changed(self, text: str):
        is_custom = text == 'Custom'
        self.custom_w.setEnabled(is_custom)
        self.custom_h.setEnabled(is_custom)
        self.unit_combo.setEnabled(is_custom)
        # If switching to Custom, initialize fields with current preset converted to selected unit
        if is_custom:
            preset_key = self.page_preset.itemText(self.page_preset.currentIndex() - 1)
            if preset_key in PAGE_PRESETS_MM:
                wmm, hmm = PAGE_PRESETS_MM[preset_key]
            else: # Default to A4 if previous was not a standard preset
                wmm, hmm = PAGE_PRESETS_MM['A4']
            
            f = self._unit_factor(self.unit_combo.currentText())
            self.custom_w.setValue(round(wmm / f, 2))
            self.custom_h.setValue(round(hmm / f, 2))
        self.update_preview()

    def on_theme_changed(self, name: str):
        self._apply_theme(name)

    def on_toggle_theme(self):
        cur = self.theme_combo.currentText()
        self.theme_combo.setCurrentText('Light' if cur == 'Dark' else 'Dark')

    def on_clear_list(self):
        if self.list_widget.count() == 0:
            return
        res = QMessageBox.question(self, 'Clear list', 'Remove all items?',
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                   QMessageBox.StandardButton.No)
        if res == QMessageBox.StandardButton.Yes:
            self.list_widget.clear()
            self.preview_label.setText('Preview')
            self.preview_label.setPixmap(QPixmap())
            self.statusBar().showMessage('List cleared', 3000)
            self._update_actions_enabled()
            self._update_info()

    def on_list_context_menu(self, pos):
        if not self.list_widget.count():
            return
        item = self.list_widget.itemAt(pos)
        if item:
            self.list_widget.setCurrentItem(item)
        menu = QMenu(self)
        act_open = menu.addAction('Open')
        act_open_dir = menu.addAction('Open Containing Folder')
        menu.addSeparator()
        act_rot_l = menu.addAction('Rotate ⟲')
        act_rot_r = menu.addAction('Rotate ⟳')
        act_remove = menu.addAction('Remove Selected')
        action = menu.exec(self.list_widget.viewport().mapToGlobal(pos))
        if not action:
            return
        if action == act_open:
            for p in self._selected_paths():
                QDesktopServices.openUrl(QUrl.fromLocalFile(str(p)))
        elif action == act_open_dir:
            for p in self._selected_paths():
                QDesktopServices.openUrl(QUrl.fromLocalFile(str(Path(p).parent)))
        elif action == act_rot_l:
            self.on_rotate(-90)
        elif action == act_rot_r:
            self.on_rotate(90)
        elif action == act_remove:
            self.on_remove_selected()

    # ------- Helpers -------
    def add_images(self, paths: Iterable[Path]):
        existing = {self.list_widget.item(i).data(Qt.ItemDataRole.UserRole) for i in range(self.list_widget.count())}
        added = 0
        for p in paths:
            try:
                if not is_image_file(p):
                    continue
                if str(p) in existing:
                    continue
                self._add_image_item(p)
                existing.add(str(p))
                added += 1
            except Exception as e:
                print(f'Failed to add {p}: {e}', file=sys.stderr)
        if added == 0:
            QMessageBox.warning(self, 'No images added', 'No new valid images were added.')
        else:
            self.statusBar().showMessage(f'Added {added} image(s)', 3000)
        self._update_actions_enabled()
        self._update_info()
        # select first item if none is current
        if self.list_widget.count() and self.list_widget.currentRow() == -1:
            self.list_widget.setCurrentRow(0)
        self.update_preview()

    def _add_image_item(self, path: Path):
        item = QListWidgetItem(path.name)
        item.setData(Qt.ItemDataRole.UserRole, str(path))
        item.setData(self.ROTATION_ROLE, 0)
        # Center text under icon in icon grid
        try:
            item.setTextAlignment(Qt.AlignmentFlag.AlignHCenter | Qt.AlignmentFlag.AlignTop)
        except Exception:
            pass
        # placeholder icon
        ph = QPixmap(self.list_widget.iconSize())
        ph.fill(QColor('#3a3a3a'))
        p = QPainter(ph)
        p.setPen(QPen(QColor('#888')))
        p.drawRect(0, 0, ph.width() - 1, ph.height() - 1)
        p.end()
        item.setIcon(QIcon(ph))
        # Size hint helps reserve space for label under thumbnail
        try:
            self.list_widget.setGridSize(QSize(self.list_widget.iconSize().width() + 20,
                                               self.list_widget.iconSize().height() + 40))
        except Exception:
            pass
        self.list_widget.addItem(item)
        # queue async thumbnail
        self._queue_thumbnail(str(path))

    def _take_all_items(self) -> List[QListWidgetItem]:
        items: List[QListWidgetItem] = []
        # takeItem removes the item without deleting it, so we can reinsert safely
        while self.list_widget.count():
            items.append(self.list_widget.takeItem(0))
        return items

    def _collect_items(self) -> List[QListWidgetItem]:
        return [self.list_widget.item(i) for i in range(self.list_widget.count())]

    def _queue_thumbnail(self, path: str):
        if not hasattr(self, '_thumb_pending'):
            self._thumb_pending = set()
        # Serve from cache if available
        key = (path, self.list_widget.iconSize().width(), self.list_widget.iconSize().height())
        if key in getattr(self, '_thumb_cache', {}):
            # Apply cached icon to the matching item
            for i in range(self.list_widget.count()):
                it = self.list_widget.item(i)
                if it.data(Qt.ItemDataRole.UserRole) == path:
                    it.setIcon(self._thumb_cache[key])
                    return
        if path in self._thumb_pending:
            return
        self._thumb_pending.add(path)
        task = _ThumbTask(path, self.list_widget.iconSize(), self._thumb_signals)
        self._thumb_pool.start(task)

    def _on_thumb_ready(self, path: str, image: QImage):
        # Build scaled icon and cache it keyed by path and icon size
        pm = QPixmap.fromImage(image)
        icon_pm = pm.scaled(self.list_widget.iconSize(), Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
        icon = QIcon(icon_pm)
        key = (path, self.list_widget.iconSize().width(), self.list_widget.iconSize().height())
        self._thumb_cache[key] = icon
        for i in range(self.list_widget.count()):
            it = self.list_widget.item(i)
            if it.data(Qt.ItemDataRole.UserRole) == path:
                it.setIcon(icon)
                break
        self._thumb_pending.discard(path)

    def _selected_paths(self) -> List[Path]:
        return [Path(it.data(Qt.ItemDataRole.UserRole)) for it in self.list_widget.selectedItems()]

    def _apply_theme(self, name: str):
        app = QApplication.instance()
        if not app:
            return
        # Use Fusion style for a consistent modern look
        fusion = QStyleFactory.create('Fusion')
        if fusion:
            app.setStyle(fusion)

        dark = (name.lower() == 'dark')
        if dark:
            pal = QPalette()
            pal.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
            pal.setColor(QPalette.ColorRole.WindowText, QColor('white'))
            pal.setColor(QPalette.ColorRole.Base, QColor(35, 35, 35))
            pal.setColor(QPalette.ColorRole.AlternateBase, QColor(53, 53, 53))
            pal.setColor(QPalette.ColorRole.ToolTipBase, QColor('white'))
            pal.setColor(QPalette.ColorRole.ToolTipText, QColor('white'))
            pal.setColor(QPalette.ColorRole.Text, QColor('white'))
            pal.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
            pal.setColor(QPalette.ColorRole.ButtonText, QColor('white'))
            pal.setColor(QPalette.ColorRole.BrightText, QColor('red'))
            pal.setColor(QPalette.ColorRole.Link, QColor(42, 130, 218))
            pal.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
            pal.setColor(QPalette.ColorRole.HighlightedText, QColor('black'))
            app.setPalette(pal)

            qss = """
            QWidget { font-size: 13px; color: #e0e0e0; font-family: 'Kantumruy Pro', 'Segoe UI', sans-serif; }
            QMainWindow { background: #1a1a1a; }
            QGroupBox { 
                border: 2px solid #3a3a3a; 
                border-radius: 10px; 
                margin-top: 12px; 
                padding: 12px 14px 14px 14px;
                background: #252525;
                font-weight: 600;
            }
            QGroupBox::title { 
                subcontrol-origin: margin; 
                left: 16px; 
                padding: 0 6px;
                color: #4fc3f7;
            }
            QPushButton { 
                padding: 8px 16px; 
                border-radius: 8px; 
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #2196F3, stop:1 #1976D2);
                color: white; 
                border: none;
                font-weight: 600;
                min-height: 28px;
            }
            QPushButton:hover { 
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #42A5F5, stop:1 #1E88E5);
            }
            QPushButton:pressed { 
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #1976D2, stop:1 #1565C0);
            }
            QPushButton:disabled { background: #3a3a3a; color: #777; }
            QLineEdit, QComboBox, QSpinBox, QDoubleSpinBox { 
                padding: 6px 10px; 
                border: 2px solid #3a3a3a; 
                border-radius: 8px; 
                background: #2b2b2b; 
                color: #e0e0e0;
                selection-background-color: #2196F3;
            }
            QLineEdit:focus, QComboBox:focus, QSpinBox:focus, QDoubleSpinBox:focus {
                border: 2px solid #2196F3;
            }
            QListWidget { 
                border: 2px solid #3a3a3a; 
                border-radius: 10px; 
                background: #252525;
                padding: 8px;
                outline: 0; /* remove focus border */
            }
            QListWidget::item { 
                padding: 6px; 
                border-radius: 8px;
                border: none; /* no item border */
                background: transparent;
            }
            QListWidget::item:selected { 
                background: rgba(33,150,243,0.22); /* soft highlight, no border */
                color: white;
                border: none;
            }
            QListWidget::item:hover { 
                background: #333;
                border: none;
            }
            QScrollBar:vertical { background: transparent; width: 12px; margin: 2px; }
            QScrollBar::handle:vertical { 
                background: #555; 
                border-radius: 6px; 
                min-height: 30px; 
            }
            QScrollBar::handle:vertical:hover { background: #666; }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0; }
            QCheckBox { spacing: 6px; }
            QStatusBar { background: #1e1e1e; color: #999; border-top: 1px solid #333; }
            QToolBar { background: #252525; border-bottom: 1px solid #333; spacing: 6px; padding: 4px; }
            QToolBar::separator { background: #444; width: 1px; margin: 4px 8px; }
            QTabWidget::pane { border: 2px solid #3a3a3a; border-radius: 8px; background: #252525; }
            QTabBar::tab { 
                background: #2b2b2b; 
                color: #aaa; 
                padding: 10px 20px; 
                border-top-left-radius: 6px; 
                border-top-right-radius: 6px;
                margin-right: 4px;
            }
            QTabBar::tab:selected { 
                background: #2196F3; 
                color: white;
                font-weight: 600;
            }
            QTabBar::tab:hover:!selected { background: #333; }
            """
            app.setStyleSheet(qss)
            # Preview background/border tuned for dark
            self.preview_label.setStyleSheet('background: #1e1e1e; border: 1px solid #444;')
        else:
            # Reset to standard palette
            app.setPalette(app.style().standardPalette())
            qss = """
            QWidget { font-size: 13px; color: #2c3e50; font-family: 'Kantumruy Pro', 'Segoe UI', sans-serif; }
            QMainWindow { background: #f5f5f5; }
            QGroupBox { 
                border: 2px solid #e0e0e0; 
                border-radius: 10px; 
                margin-top: 12px; 
                padding: 12px 14px 14px 14px;
                background: white;
                font-weight: 600;
            }
            QGroupBox::title { 
                subcontrol-origin: margin; 
                left: 16px; 
                padding: 0 6px;
                color: #1976D2;
            }
            QPushButton { 
                padding: 8px 16px; 
                border-radius: 8px; 
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #2196F3, stop:1 #1976D2);
                color: white; 
                border: none;
                font-weight: 600;
                min-height: 28px;
            }
            QPushButton:hover { 
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #42A5F5, stop:1 #1E88E5);
            }
            QPushButton:pressed { 
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #1976D2, stop:1 #1565C0);
            }
            QPushButton:disabled { background: #e0e0e0; color: #999; }
            QLineEdit, QComboBox, QSpinBox, QDoubleSpinBox { 
                padding: 6px 10px; 
                border: 2px solid #ddd; 
                border-radius: 8px; 
                background: white; 
                color: #2c3e50;
                selection-background-color: #2196F3;
            }
            QLineEdit:focus, QComboBox:focus, QSpinBox:focus, QDoubleSpinBox:focus {
                border: 2px solid #2196F3;
            }
            QListWidget { 
                border: 2px solid #e0e0e0; 
                border-radius: 10px; 
                background: white;
                padding: 8px;
                outline: 0; /* remove focus border */
            }
            QListWidget::item { 
                padding: 6px; 
                border-radius: 8px;
                border: none; /* no item border */
                background: transparent;
            }
            QListWidget::item:selected { 
                background: rgba(33,150,243,0.18); /* soft highlight, no border */
                color: #0d47a1;
                border: none;
            }
            QListWidget::item:hover { 
                background: #f0f0f0;
                border: none;
            }
            QScrollBar:vertical { background: transparent; width: 12px; margin: 2px; }
            QScrollBar::handle:vertical { 
                background: #bbb; 
                border-radius: 6px; 
                min-height: 30px; 
            }
            QScrollBar::handle:vertical:hover { background: #999; }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0; }
            QCheckBox { spacing: 6px; }
            QStatusBar { background: #fafafa; color: #666; border-top: 1px solid #e0e0e0; }
            QToolBar { background: white; border-bottom: 1px solid #e0e0e0; spacing: 6px; padding: 4px; }
            QToolBar::separator { background: #ddd; width: 1px; margin: 4px 8px; }
            QTabWidget::pane { border: 2px solid #e0e0e0; border-radius: 8px; background: white; }
            QTabBar::tab { 
                background: #f5f5f5; 
                color: #666; 
                padding: 10px 20px; 
                border-top-left-radius: 6px; 
                border-top-right-radius: 6px;
                margin-right: 4px;
            }
            QTabBar::tab:selected { 
                background: #2196F3; 
                color: white;
                font-weight: 600;
            }
            QTabBar::tab:hover:!selected { background: #e8e8e8; }
            """
            app.setStyleSheet(qss)
            # Preview background/border tuned for light
            self.preview_label.setStyleSheet('background: #fafafa; border: 1px solid #ddd;')

    def _collect_paths(self) -> List[Path]:
        out: List[Path] = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            p = Path(item.data(Qt.ItemDataRole.UserRole))
            out.append(p)
        return out

    def _update_info(self):
        n = self.list_widget.count()
        if n == 0:
            self.info_label.setText('Add images or drop files/folders here\nDrag to reorder • Ctrl+O to add files')
        elif n == 1:
            self.info_label.setText(f'{n} image ready • Ready to convert to PDF')
        else:
            self.info_label.setText(f'{n} images ready • Ready to convert to PDF')

    def _update_actions_enabled(self):
        has_items = self.list_widget.count() > 0
        try:
            self.btn_save.setEnabled(has_items)
        except Exception:
            pass
        try:
            self.act_save.setEnabled(has_items)
        except Exception:
            pass

    def _load_settings(self):
        try:
            # last directory
            last = self._qsettings.value('last_dir', '', type=str)
            if last:
                p = Path(last)
                if p.exists():
                    self.last_dir = p
            # theme
            theme = self._qsettings.value('theme', self.theme_combo.currentText(), type=str)
            self.theme_combo.setCurrentText(theme)
            # page preset and options
            preset = self._qsettings.value('page_preset', self.page_preset.currentText(), type=str)
            if preset:
                try:
                    self.page_preset.setCurrentText(preset)
                except Exception:
                    pass
            self.orientation.setCurrentText(self._qsettings.value('orientation', self.orientation.currentText(), type=str))
            self.unit_combo.setCurrentText(self._qsettings.value('unit', self.unit_combo.currentText(), type=str))
            self.custom_w.setValue(float(self._qsettings.value('custom_w', self.custom_w.value())))
            self.custom_h.setValue(float(self._qsettings.value('custom_h', self.custom_h.value())))
            self.margin.setValue(float(self._qsettings.value('margin', self.margin.value())))
            self.dpi_spin.setValue(int(self._qsettings.value('dpi', self.dpi_spin.value())))
            self.fit_mode.setCurrentText(self._qsettings.value('fit', self.fit_mode.currentText(), type=str))
            self.quality_spin.setValue(int(self._qsettings.value('quality', self.quality_spin.value())))
            self.page_numbers_cb.setChecked(self._qsettings.value('page_numbers', self.page_numbers_cb.isChecked(), type=bool))
            self.page_num_pos.setCurrentText(self._qsettings.value('page_num_pos', self.page_num_pos.currentText(), type=str))
            self.page_num_size.setValue(int(self._qsettings.value('page_num_size', self.page_num_size.value())))
            self.title_edit.setText(self._qsettings.value('title', self.title_edit.text(), type=str))
            self.author_edit.setText(self._qsettings.value('author', self.author_edit.text(), type=str))
            self.subject_edit.setText(self._qsettings.value('subject', self.subject_edit.text(), type=str))
            self.keywords_edit.setText(self._qsettings.value('keywords', self.keywords_edit.text(), type=str))
        except Exception:
            pass

    def _save_settings(self):
        try:
            if self.last_dir:
                self._qsettings.setValue('last_dir', str(self.last_dir))
            self._qsettings.setValue('theme', self.theme_combo.currentText())
            self._qsettings.setValue('page_preset', self.page_preset.currentText())
            self._qsettings.setValue('orientation', self.orientation.currentText())
            self._qsettings.setValue('unit', self.unit_combo.currentText())
            self._qsettings.setValue('custom_w', self.custom_w.value())
            self._qsettings.setValue('custom_h', self.custom_h.value())
            self._qsettings.setValue('margin', self.margin.value())
            self._qsettings.setValue('dpi', self.dpi_spin.value())
            self._qsettings.setValue('fit', self.fit_mode.currentText())
            self._qsettings.setValue('quality', self.quality_spin.value())
            self._qsettings.setValue('page_numbers', self.page_numbers_cb.isChecked())
            self._qsettings.setValue('page_num_pos', self.page_num_pos.currentText())
            self._qsettings.setValue('page_num_size', self.page_num_size.value())
            self._qsettings.setValue('title', self.title_edit.text())
            self._qsettings.setValue('author', self.author_edit.text())
            self._qsettings.setValue('subject', self.subject_edit.text())
            self._qsettings.setValue('keywords', self.keywords_edit.text())
        except Exception:
            pass

    # Units helpers
    def _unit_factor(self, unit: str) -> float:
        # mm per unit
        return 1.0 if unit == 'mm' else 10.0  # 'cm'

    def on_unit_changed(self, unit: str):
        # Convert current custom size and margin values to preserve mm internally
        try:
            prev_unit = 'cm' if unit == 'mm' else 'mm'
            # Actually detect previous from suffix of custom_w
            if self.custom_w.suffix().strip() == 'cm':
                prev_unit = 'cm'
            else:
                prev_unit = 'mm'
            f_prev = self._unit_factor(prev_unit)
            f_new = self._unit_factor(unit)
            # Read current values in mm
            w_mm = self.custom_w.value() * f_prev
            h_mm = self.custom_h.value() * f_prev
            m_mm = self.margin.value() * f_prev
            # Update ranges and suffixes
            if unit == 'mm':
                self.custom_w.setRange(10.0, 2000.0)
                self.custom_h.setRange(10.0, 2000.0)
                self.margin.setRange(0.0, 100.0)
            else:
                self.custom_w.setRange(1.0, 200.0)
                self.custom_h.setRange(1.0, 200.0)
                self.margin.setRange(0.0, 10.0)
            self.custom_w.setSuffix(f' {unit}')
            self.custom_h.setSuffix(f' {unit}')
            self.margin.setSuffix(f' {unit}')
            # Write converted values
            self.custom_w.setValue(round(w_mm / f_new, 2))
            self.custom_h.setValue(round(h_mm / f_new, 2))
            self.margin.setValue(round(m_mm / f_new, 2))
        except Exception:
            pass
        self.update_preview()

    def _current_settings(self) -> ExportSettings:
        preset = self.page_preset.currentText()
        if preset == 'Custom':
            f = self._unit_factor(self.unit_combo.currentText())
            wmm, hmm = self.custom_w.value() * f, self.custom_h.value() * f
        else:
            wmm, hmm = PAGE_PRESETS_MM[preset]
        ori = self.orientation.currentText()
        f = self._unit_factor(self.unit_combo.currentText())
        margin = self.margin.value() * f
        dpi = self.dpi_spin.value()
        fit = self.fit_mode.currentText()
        quality = self.quality_spin.value()
        return ExportSettings(
            page_mm=(wmm, hmm),
            orientation=ori,
            margin_mm=margin,
            dpi=dpi,
            fit_mode=fit,
            quality=quality,
            title=self.title_edit.text(),
            author=self.author_edit.text(),
            subject=self.subject_edit.text(),
            keywords=self.keywords_edit.text(),
            user_password=self.user_pwd_edit.text(),
            owner_password=self.owner_pwd_edit.text(),
            page_numbers=self.page_numbers_cb.isChecked() if hasattr(self, 'page_numbers_cb') else False,
            page_number_pos=self.page_num_pos.currentText() if hasattr(self, 'page_num_pos') else 'Bottom-Center',
            page_number_size_pt=self.page_num_size.value() if hasattr(self, 'page_num_size') else 12,
        )

    def _page_px(self, settings: ExportSettings) -> Tuple[int, int]:
        wmm, hmm = settings.page_mm
        if settings.orientation == 'Landscape':
            wmm, hmm = hmm, wmm
        w = int(round(wmm / 25.4 * settings.dpi))
        h = int(round(hmm / 25.4 * settings.dpi))
        return max(w, 1), max(h, 1)

    def _margin_px(self, settings: ExportSettings) -> int:
        return int(round(settings.margin_mm / 25.4 * settings.dpi))

    def _place_rect(self, img_w: int, img_h: int, rect_w: int, rect_h: int, mode: str) -> Tuple[int, int, int, int, Optional[Tuple[int, int, int, int]]]:
        # returns dest x, y, w, h and optional crop rect (x, y, w, h) from the resized image
        if mode == 'Center':
            w, h = min(img_w, rect_w), min(img_h, rect_h)
            x = (rect_w - w) // 2
            y = (rect_h - h) // 2
            return x, y, w, h, None
        # compute scale
        sx = rect_w / img_w
        sy = rect_h / img_h
        if mode == 'Fit':
            s = min(sx, sy)
            w = int(img_w * s)
            h = int(img_h * s)
            x = (rect_w - w) // 2
            y = (rect_h - h) // 2
            return x, y, w, h, None
        # Fill
        s = max(sx, sy)
        w = int(img_w * s)
        h = int(img_h * s)
        x = (rect_w - w) // 2
        y = (rect_h - h) // 2
        # crop to rect
        crop_x = max(-x, 0)
        crop_y = max(-y, 0)
        crop_w = min(rect_w, w) - max(0, x)
        crop_h = min(rect_h, h) - max(0, y)
        return x, y, w, h, (crop_x, crop_y, crop_w, crop_h)

    def update_preview(self):
        # Debounce heavy preview rendering
        try:
            self._preview_timer.start(50)
        except Exception:
            # Fallback if timer not available
            self._render_preview()

    def _render_preview(self):
        it = self.list_widget.currentItem()
        if not it and self.list_widget.count():
            # pick the first item by default to show a preview
            self.list_widget.setCurrentRow(0)
            it = self.list_widget.currentItem()
        if not it:
            self.preview_label.setText('Preview')
            self.preview_label.setPixmap(QPixmap())
            self._last_preview_key = None
            return
        settings = self._current_settings()
        # Build a cache key; include file mtime and relevant settings
        path_str = it.data(Qt.ItemDataRole.UserRole)
        try:
            mtime = os.path.getmtime(path_str)
        except Exception:
            mtime = 0
        key = (
            path_str,
            it.data(self.ROTATION_ROLE) or 0,
            settings.page_mm,
            settings.orientation,
            settings.margin_mm,
            settings.dpi,
            settings.fit_mode,
            settings.page_numbers,
            settings.page_number_pos,
            settings.page_number_size_pt,
            mtime,
        )
        if self._last_preview_key == key and self._last_preview is not None and not self._last_preview.isNull():
            self._apply_preview_zoom()
            return

        page_w, page_h = 360, 480  # preview area
        page_pix = QPixmap(page_w, page_h)
        page_pix.fill(QColor('white'))

        painter = QPainter(page_pix)
        painter.setRenderHints(QPainter.RenderHint.Antialiasing | QPainter.RenderHint.SmoothPixmapTransform)

        # compute content rect based on margins (scaled to preview)
        pw, ph = self._page_px(settings)
        m = self._margin_px(settings)
        cw, ch = pw - 2 * m, ph - 2 * m
        if cw < 1 or ch < 1:
            cw, ch = 1, 1
        # scale preview proportionally to page
        scale = min(page_w / pw, page_h / ph)
        scaled_pw = int(pw * scale)
        scaled_ph = int(ph * scale)
        page_x = (page_w - scaled_pw) // 2
        page_y = (page_h - scaled_ph) // 2
        # draw page border
        pen = QPen(QColor('#cccccc'))
        pen.setWidth(2)
        painter.setPen(pen)
        painter.drawRect(QRect(page_x, page_y, scaled_pw - 1, scaled_ph - 1))
        # content rect in preview coords
        sm = int(m * scale)
        content = QRect(page_x + sm, page_y + sm, max(1, scaled_pw - 2 * sm), max(1, scaled_ph - 2 * sm))
        # draw margin area outline
        # draw margin area outline only if margin > 0
        if m > 0:
            pen = QPen(QColor('#e0e0e0'))
            painter.setPen(pen)
            painter.drawRect(content)
        # Load image using Qt first for robustness; Pillow as a last resort
        pix = QPixmap()
        try:
            # Try to pre-scale to content area to reduce memory usage
            target = QSize(max(1, content.width()), max(1, content.height()))
            reader = QImageReader(path_str)
            reader.setAutoTransform(True)
            try:
                # Preserve aspect ratio when asking decoder to scale
                orig_sz = reader.size()
                if orig_sz.isValid():
                    s = min(max(1, target.width()) / max(1, orig_sz.width()),
                            max(1, target.height()) / max(1, orig_sz.height()))
                    sw = max(1, int(orig_sz.width() * s))
                    sh = max(1, int(orig_sz.height() * s))
                    reader.setScaledSize(QSize(sw, sh))
            except Exception:
                pass
            img = reader.read()
            if not img.isNull():
                pm = QPixmap.fromImage(img)
            else:
                pm = QPixmap(path_str)
            # If still null, try Pillow
            if pm.isNull():
                qimg = _load_qimage_via_pillow(path_str, target)
                if qimg is not None and not qimg.isNull():
                    pm = QPixmap.fromImage(qimg)
            # Apply manual rotation if set
            if (it.data(self.ROTATION_ROLE) or 0) % 360 and not pm.isNull():
                rot = (it.data(self.ROTATION_ROLE) or 0) % 360
                pm = pm.transformed(QTransform().rotate(rot), Qt.TransformationMode.SmoothTransformation)
            pix = pm
        except Exception:
            # Last-resort fallback
            pm = QPixmap(path_str)
            if not pm.isNull():
                rot = (it.data(self.ROTATION_ROLE) or 0) % 360
                if rot:
                    pm = pm.transformed(QTransform().rotate(rot), Qt.TransformationMode.SmoothTransformation)
            pix = pm

        if not pix.isNull():
            # placement
            iw, ih = pix.width(), pix.height()
            mode = settings.fit_mode
            dx, dy, dw, dh, crop = self._place_rect(iw, ih, content.width(), content.height(), mode)
            if mode == 'Center':
                # No scaling; clip if needed and center
                region = pix.copy(0, 0, min(iw, content.width()), min(ih, content.height()))
                ox = content.x() + (content.width() - region.width()) // 2
                oy = content.y() + (content.height() - region.height()) // 2
                painter.drawPixmap(ox, oy, region)
            else:
                if crop:
                    # Fill: scale by expanding, then crop to content rect
                    cx, cy, cw2, ch2 = crop
                    sp = pix.scaled(dw, dh, Qt.AspectRatioMode.KeepAspectRatioByExpanding, Qt.TransformationMode.SmoothTransformation)
                    sp = sp.copy(cx, cy, cw2, ch2)
                    painter.drawPixmap(content.x(), content.y(), sp)
                else:
                    # Fit: scale to target size respecting aspect
                    sp = pix.scaled(dw, dh, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                    painter.drawPixmap(content.x() + dx, content.y() + dy, sp)
        # Page numbering overlay (preview)
        if settings.page_numbers:
            idx = max(self.list_widget.currentRow(), 0) + 1
            total = max(self.list_widget.count(), 1)
            self._draw_page_number_preview(painter, content, settings, idx, total)
        painter.end()
        self._last_preview_key = key
        self._last_preview = page_pix
        self._apply_preview_zoom()
        self._last_preview = page_pix
        self._apply_preview_zoom()

    def on_save_pdf(self):
        items = self._collect_items()
        if not items:
            QMessageBox.warning(self, 'No images', 'Add images before saving.')
            return

        default_dir = self.last_dir or Path.home()
        out_path_str, _ = QFileDialog.getSaveFileName(self, 'Save PDF', str(default_dir / 'output.pdf'), 'PDF (*.pdf)')
        if not out_path_str:
            return
        out_path = Path(out_path_str)
        settings = self._current_settings()

        progress = QProgressDialog('Exporting images to PDF…', 'Cancel', 0, len(items) + 1, self)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setAutoClose(True)
        progress.setValue(0)

        canceled = False
        try:
            canceled = self._save_images_to_pdf(items, settings, out_path, progress)
        except KeyboardInterrupt:
            canceled = True
        except Exception as e:
            progress.close()
            traceback.print_exc()
            QMessageBox.critical(self, 'Error', f'Failed to save PDF:\n{e}')
            return
        finally:
            progress.close()

        if canceled:
            self.statusBar().showMessage('Export canceled', 4000)
            return
        self.statusBar().showMessage(f'Saved to {out_path}', 5000)
        self.last_dir = out_path.parent
        self._save_settings()
        res = QMessageBox.question(self, 'Done', f'Saved PDF to:\n{out_path}\n\nOpen it now?',
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                   QMessageBox.StandardButton.Yes)
        if res == QMessageBox.StandardButton.Yes:
            QDesktopServices.openUrl(QUrl.fromLocalFile(str(out_path)))

    # Core conversion using Pillow (optimized)
    def _save_images_to_pdf(self, items: List[QListWidgetItem], settings: ExportSettings, out_path: Path, progress: Optional[QProgressDialog] = None) -> bool:
        # Returns True if canceled, False otherwise.
        # This is a hybrid approach:
        # 1. Use Pillow to efficiently create an in-memory, multi-page PDF.
        # 2. Use PyPDF2 to add encryption to the generated PDF.
        try:
            from PyPDF2 import PdfReader, PdfWriter
        except ImportError:
            QMessageBox.critical(self, "Dependency Missing", "PyPDF2 is required for PDF creation. Please install it (`pip install PyPDF2`).")
            return True

        pw, ph = self._page_px(settings)
        m = self._margin_px(settings)
        cw, ch = max(1, pw - 2 * m), max(1, ph - 2 * m)

        total_items = len(items)
        if total_items == 0:
            raise ValueError('No images to save')

        image_list_for_pdf = []
        try:
            for idx0, it in enumerate(items, start=1):
                if progress:
                    progress.setLabelText(f'Processing image {idx0}/{total_items}…')
                    progress.setValue(idx0 - 1)
                    QApplication.processEvents()
                    if progress.wasCanceled(): return True
                
                p = Path(it.data(Qt.ItemDataRole.UserRole))
                
                with Image.open(p) as img:
                    rot = (it.data(self.ROTATION_ROLE) or 0) % 360
                    if rot: img = img.rotate(-rot, expand=True)
                    
                    if img.mode in ('RGBA', 'LA', 'P'):
                        bg = Image.new('RGB', img.size, (255, 255, 255))
                        if img.mode == 'P': img = img.convert('RGBA')
                        bg.paste(img, mask=img.split()[-1] if img.mode in ('RGBA', 'LA') else None)
                        img = bg
                    elif img.mode != 'RGB':
                        img = img.convert('RGB')

                    page = Image.new('RGB', (pw, ph), (255, 255, 255))
                    cx0, cy0, cw_, ch_ = m, m, cw, ch
                    iw, ih = img.size
                    mode = settings.fit_mode
                    try: RESAMPLE = Image.Resampling.LANCZOS
                    except AttributeError: RESAMPLE = Image.LANCZOS

                    if mode == 'Center':
                        w2, h2 = min(iw, cw_), min(ih, ch_)
                        crop_x, crop_y = max(0, (iw - w2) // 2), max(0, (ih - h2) // 2)
                        region = img.crop((crop_x, crop_y, crop_x + w2, crop_y + h2))
                        ox, oy = cx0 + (cw_ - w2) // 2, cy0 + (ch_ - h2) // 2
                        page.paste(region, (ox, oy))
                    elif mode == 'Fit':
                        s = min(cw_ / max(1, iw), ch_ / max(1, ih))
                        w2, h2 = max(1, int(round(iw * s))), max(1, int(round(ih * s)))
                        region = img.resize((w2, h2), RESAMPLE)
                        ox, oy = cx0 + (cw_ - w2) // 2, cy0 + (ch_ - h2) // 2
                        page.paste(region, (ox, oy))
                    else: # 'Fill'
                        s = max(cw_ / max(1, iw), ch_ / max(1, ih))
                        w2, h2 = max(1, int(round(iw * s))), max(1, int(round(ih * s)))
                        big = img.resize((w2, h2), RESAMPLE)
                        crop_x, crop_y = max(0, (w2 - cw_) // 2), max(0, (h2 - ch_) // 2)
                        region = big.crop((crop_x, crop_y, crop_x + cw_, crop_y + ch_))
                        page.paste(region, (cx0, cy0))

                    if settings.page_numbers and ImageDraw:
                        draw = ImageDraw.Draw(page)
                        text = f"{idx0} / {total_items}"
                        size_px = max(8, int(round(settings.page_number_size_pt * settings.dpi / 72)))
                        try: font = ImageFont.truetype("arial.ttf", size_px)
                        except Exception:
                            try: font = ImageFont.truetype("DejaVuSans.ttf", size_px)
                            except Exception: font = ImageFont.load_default()
                        
                        try: bbox = draw.textbbox((0, 0), text, font=font)
                        except AttributeError: # Fallback for older Pillow
                            tw, th = draw.textsize(text, font=font)
                            bbox = (0, 0, tw, th)

                        tw, th = bbox[2] - bbox[0], bbox[3] - bbox[1]
                        pad = max(4, size_px // 4)
                        pos = settings.page_number_pos
                        y = cy0 + ch_ - (th + pad * 2) if 'Bottom' in pos else cy0 + pad
                        if 'Left' in pos: x = cx0 + pad
                        elif 'Right' in pos: x = cx0 + cw_ - (tw + pad * 2)
                        else: x = cx0 + (cw_ - (tw + pad * 2)) // 2
                        
                        box_x0, box_y0 = x - pad, y - pad
                        draw.rectangle((box_x0, box_y0, box_x0 + tw + 2*pad, box_y0 + th + 2*pad), fill=(255, 255, 255), outline=(180, 180, 180))
                        draw.text((x, y), text, fill=(0, 0, 0), font=font)
                    
                    image_list_for_pdf.append(page)

            if progress:
                progress.setLabelText('Building PDF…')
                progress.setValue(total_items)
                QApplication.processEvents()
                if progress.wasCanceled(): return True

            pdf_buffer = io.BytesIO()
            if image_list_for_pdf:
                image_list_for_pdf[0].save(
                    pdf_buffer,
                    format='PDF',
                    resolution=float(settings.dpi),
                    quality=int(settings.quality),
                    subsampling=0,  # 4:4:4 for best quality
                    optimize=True,
                    save_all=True,
                    append_images=image_list_for_pdf[1:],
                    title=settings.title,
                    author=settings.author,
                    subject=settings.subject,
                    keywords=settings.keywords
                )
            
            pdf_buffer.seek(0)
            
            reader = PdfReader(pdf_buffer)
            writer = PdfWriter()
            writer.append_pages_from_reader(reader)

            meta = {'/Producer': f'{APP_NAME} v{APP_VERSION}'}
            if settings.title: meta['/Title'] = settings.title
            if settings.author: meta['/Author'] = settings.author
            if settings.subject: meta['/Subject'] = settings.subject
            if settings.keywords: meta['/Keywords'] = settings.keywords
            if meta: writer.add_metadata(meta)

            if settings.user_password or settings.owner_password:
                upw = settings.user_password or ''
                opw = settings.owner_password or upw or ''
                writer.encrypt(user_password=upw, owner_password=opw)
            
            with out_path.open('wb') as f: writer.write(f)
            
            if progress: progress.setValue(total_items + 1)
            return False
        finally:
            for img in image_list_for_pdf: img.close()

    def _draw_page_number_preview(self, painter: QPainter, content: QRect, settings: ExportSettings, idx: int, total: int):
        text = f"{idx} / {total}"
        f = painter.font()
        f.setPointSizeF(max(6.0, float(settings.page_number_size_pt)))
        painter.setFont(f)
        fm = painter.fontMetrics()
        tw = fm.horizontalAdvance(text)
        th = fm.height()
        pad = 6
        if 'Bottom' in settings.page_number_pos:
            y = content.y() + content.height() - (th + 2 * pad)
        else:
            y = content.y()
        if 'Left' in settings.page_number_pos:
            x = content.x()
        elif 'Right' in settings.page_number_pos:
            x = content.x() + content.width() - (tw + 2 * pad)
        else:
            x = content.x() + (content.width() - (tw + 2 * pad)) // 2
        r = QRect(x, y, tw + 2 * pad, th + 2 * pad)
        painter.fillRect(r, QColor(255, 255, 255, 220))
        painter.setPen(QPen(QColor(0, 0, 0)))
        painter.drawRect(r)
        painter.drawText(r, Qt.AlignmentFlag.AlignCenter, text)

    # ------- Preview zoom helpers -------
    def _apply_preview_zoom(self):
        if not self._last_preview or self._last_preview.isNull():
            self.preview_label.setText('Preview')
            self.preview_label.setPixmap(QPixmap())
            return
        pm = self._last_preview
        if self.preview_fit:
            vw = self.preview_area.viewport().width()
            vh = self.preview_area.viewport().height()
            if vw <= 2 or vh <= 2:
                s = 1.0
            else:
                s = min(vw / pm.width(), vh / pm.height())
            self.preview_zoom = max(0.05, min(s, 8.0))
        w = max(1, int(pm.width() * self.preview_zoom))
        h = max(1, int(pm.height() * self.preview_zoom))
        spm = pm.scaled(w, h, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
        self.preview_label.setPixmap(spm)
        self.preview_label.resize(spm.size())
        self.zoom_label.setText(f"{int(round(self.preview_zoom * 100))}%")

    def on_zoom_fit_toggled(self, on: bool):
        self.preview_fit = on
        if on:
            self._apply_preview_zoom()
        else:
            # keep current zoom factor but reapply
            self._apply_preview_zoom()

    def on_zoom_reset(self):
        self.preview_fit = False
        self.preview_zoom = 1.0
        self.zoom_fit_cb.setChecked(False)
        self._apply_preview_zoom()

    def on_zoom_step(self, factor: float):
        self.preview_fit = False
        self.zoom_fit_cb.setChecked(False)
        self.preview_zoom = max(0.05, min(self.preview_zoom * factor, 8.0))
        self._apply_preview_zoom()

    # -------- Intro dialog --------
    def _maybe_show_intro(self):
        seen = False
        try:
            seen = bool(self._qsettings.value('intro_seen', False, type=bool))
        except Exception:
            seen = False
        if not seen:
            self._show_intro_dialog(set_seen=True)

    def on_show_intro(self):
        self._show_intro_dialog(set_seen=False)

    def _show_intro_dialog(self, set_seen: bool = False):
        dlg = QDialog(self)
        dlg.setWindowTitle('Welcome to Image to PDF')
        lay = QVBoxLayout(dlg)
        msg = QLabel(
            'Convert images into a single PDF quickly.\n\n'
            'Steps:\n'
            '1) Add Images or Add Folder (or drag & drop).\n'
            '2) Adjust Page, Quality, and Info if needed.\n'
            '3) Click Save as PDF.\n\n'
            'Tips: Use Fit mode for no cropping. Rotate from toolbar or context menu.'
        )
        msg.setWordWrap(True)
        lay.addWidget(msg)
        chk = QCheckBox("Don't show this again")
        if set_seen:
            chk.setChecked(True)
        # Tame checkbox style so it looks native inside the intro dialog
        # Use native checkbox look in this dialog (no custom style)
        lay.addWidget(chk)
        btns = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok)
        btns.accepted.connect(dlg.accept)
        lay.addWidget(btns)
        dlg.exec()
        try:
            if chk.isChecked():
                self._qsettings.setValue('intro_seen', True)
        except Exception:
            pass
def _set_windows_app_id(app_id: str) -> None:
    if sys.platform.startswith('win'):
        try:
            import ctypes
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(ctypes.c_wchar_p(app_id))
        except Exception:
            pass


def _load_app_icon(base: Path) -> QIcon:
    # Try ICO first, then PNG; for PNG, add multiple sizes for crisp scaling
    try:
        candidates = ['icon.ico', 'app.ico', 'icon.png', 'app.png']
        for name in candidates:
            p = base / name
            if not p.exists():
                continue
            if p.suffix.lower() == '.ico':
                return QIcon(str(p))
            # PNG fallback: build a multi-size QIcon
            icon = QIcon()
            for s in (16, 24, 32, 48, 64, 128, 256):
                icon.addFile(str(p), QSize(s, s))
            if not icon.isNull():
                return icon
    except Exception:
        pass
    return QIcon()


def _load_custom_icon(base: Path, stems: Iterable[str]) -> QIcon:
    """Search for a custom icon by stem name in common folders.
    Order: icons/, assets/icons/, asset/icons/, resources/, res, img, images, and base dir.
    Supports .svg, .png, .ico. Returns empty QIcon if not found.
    """
    try:
        folders = ('icons', 'assets/icons', 'asset/icons', 'resources', 'res', 'img', 'images', '.')
        exts = ('.svg', '.png', '.ico')
        for folder in folders:
            for stem in stems:
                for ext in exts:
                    p = base / folder / f"{stem}{ext}" if folder != '.' else base / f"{stem}{ext}"
                    if p.exists():
                        return QIcon(str(p))
    except Exception:
        pass
    return QIcon()


def _load_icon_url_map(base: Path) -> dict:
    """Load optional icon URL mapping from icon_urls.json or icons.json.
    If none exist, return built-in defaults.
    """
    try:
        import json
        for name in ('icon_urls.json', 'icons.json'):
            p = base / name
            if p.exists():
                data = json.loads(p.read_text(encoding='utf-8')) or {}
                # Fill any missing keys from defaults
                try:
                    for k, v in ICON_URL_DEFAULTS.items():
                        data.setdefault(k, v)
                except Exception:
                    pass
                return data
    except Exception:
        pass
    try:
        return dict(ICON_URL_DEFAULTS)
    except Exception:
        return {}


def _icon_from_url(url: str, cache_dir: Path) -> QIcon:
    """Download an icon from URL with a small cache. Supports svg/png/ico.
    - Adds a UA header (some CDNs block default UA)
    - Accepts query-string URLs and content-type sniffing
    - Debug with env ICON_DEBUG=1
    """
    try:
        # data: URL support
        if url.startswith('data:'):
            try:
                import base64
                head, b64 = url.split(',', 1)
                ct = head.split(';')[0][5:] if ';' in head else 'image/png'
                data = base64.b64decode(b64)
                # choose ext from content-type
                ext = '.svg' if 'svg' in ct else ('.ico' if 'ico' in ct else '.png')
                cache_dir.mkdir(parents=True, exist_ok=True)
                h = hashlib.sha1(url.encode('utf-8')).hexdigest()
                f = cache_dir / f"{h}{ext}"
                f.write_bytes(data)
                return QIcon(str(f))
            except Exception:
                return QIcon()

        cache_dir.mkdir(parents=True, exist_ok=True)
        h = hashlib.sha1(url.encode('utf-8')).hexdigest()  # noqa: S324 (non-crypto)
        # Pick extension from url if present (ignoring query string)
        low = url.lower().split('?', 1)[0]
        ext = '.png'
        for e in ('.svg', '.png', '.ico'):
            if low.endswith(e):
                ext = e
                break
        f = cache_dir / f"{h}{ext}"
        if not f.exists():
            import requests
            headers = {
                'User-Agent': f'{APP_NAME}/{APP_VERSION} (+https://local.app)',
                'Accept': 'image/svg+xml,image/png,image/x-icon,image/*;q=0.9,*/*;q=0.1',
            }
            try:
                r = requests.get(url, timeout=12, headers=headers, allow_redirects=True)
            except Exception as e:
                if os.getenv('ICON_DEBUG'): print(f"[icon] request failed: {url} error={e}", file=sys.stderr)
                return QIcon()
            if not r.ok:
                if os.getenv('ICON_DEBUG'): print(f"[icon] HTTP {r.status_code} for {url}", file=sys.stderr)
                return QIcon()
            data = r.content
            ct = r.headers.get('content-type', '').lower()
            # Sniff type if header is missing/incorrect
            sniff = data[:64].lstrip()
            if b'<svg' in sniff or 'svg' in ct: ext = '.svg'
            elif sniff.startswith(b'\x89PNG') or 'png' in ct: ext = '.png'
            elif sniff.startswith(b'\x00\x00\x01\x00') or 'ico' in ct or 'x-icon' in ct: ext = '.ico'
            else: ext = '.png' # Default to png
            
            f = cache_dir / f"{h}{ext}"
            try: f.write_bytes(data)
            except Exception as e:
                if os.getenv('ICON_DEBUG'): print(f"[icon] write failed: {f} error={e}", file=sys.stderr)
                return QIcon()
        ic = QIcon(str(f))
        if ic.isNull() and os.getenv('ICON_DEBUG'): print(f"[icon] QIcon null from {f}", file=sys.stderr)
        return ic
    except Exception as e:
        if os.getenv('ICON_DEBUG'): print(f"[icon] unexpected error: {e}", file=sys.stderr)
        return QIcon()


def _load_preferred_font(base: Path) -> str:
    # Try to load Kantumruy Pro Medium from local files; fall back to installed fonts
    candidates = [
        'KantumruyPro-Medium.ttf',
        'Kantumruy Pro Medium.ttf',
        'KantumruyPro[wght].ttf',
        'Kantumruy Pro.ttf',
        'fonts/KantumruyPro-Medium.ttf',
        'fonts/KantumruyPro[wght].ttf',
    ]
    family = ''
    for name in candidates:
        p = base / name
        try:
            if p.exists():
                fid = QFontDatabase.addApplicationFont(str(p))
                if fid != -1:
                    fams = QFontDatabase.applicationFontFamilies(fid)
                    if fams:
                        family = fams[0]
                        break
        except Exception:
            pass
    if not family and 'Kantumruy Pro' in QFontDatabase.families(QFontDatabase.WritingSystem.Any):
        family = 'Kantumruy Pro'
    return family


def _load_fontawesome(base: Path) -> str:
    # Try common Font Awesome 5/6 Free Solid font files
    candidates = [
        'fa-solid-900.ttf',
        'Font Awesome 6 Free-Solid-900.otf',
        'Font Awesome 5 Free-Solid-900.otf',
        'fonts/fa-solid-900.ttf',
        'fonts/Font Awesome 6 Free-Solid-900.otf',
        'fonts/Font Awesome 5 Free-Solid-900.otf',
    ]
    fam = ''
    for name in candidates:
        p = base / name
        try:
            if p.exists():
                fid = QFontDatabase.addApplicationFont(str(p))
                if fid != -1:
                    fams = QFontDatabase.applicationFontFamilies(fid)
                    if fams:
                        fam = fams[0]
                        break
        except Exception:
            pass
    return fam


def _fa_icon(family: str, codepoint: int, size: int = 18, color: QColor | None = None) -> QIcon:
    try:
        pm = QPixmap(size, size)
        pm.fill(Qt.GlobalColor.transparent)
        p = QPainter(pm)
        p.setRenderHints(QPainter.RenderHint.Antialiasing | QPainter.RenderHint.TextAntialiasing)
        if color is None:
            # Default to the application's standard text color for theme compatibility
            color = QApplication.instance().palette().color(QPalette.ColorRole.WindowText)
        p.setPen(QPen(color))
        f = QFont(family)
        f.setPointSizeF(float(size))
        p.setFont(f)
        p.drawText(QRect(0, 0, size, size), int(Qt.AlignmentFlag.AlignCenter), chr(codepoint))
        p.end()
        return QIcon(pm)
    except Exception:
        return QIcon()


def _load_telegram_credentials(base: Path) -> tuple[Optional[str], Optional[str]]:
    # Order: environment variables first, then local json file 'telegram.json'
    token = os.getenv('TELEGRAM_BOT_TOKEN')
    chat_id = os.getenv('TELEGRAM_CHAT_ID')
    if token and chat_id:
        return token, chat_id
    try:
        cfg = base / 'telegram.json'
        if cfg.exists():
            import json
            data = json.loads(cfg.read_text(encoding='utf-8'))
            t = data.get('TELEGRAM_BOT_TOKEN') or data.get('token')
            c = data.get('TELEGRAM_CHAT_ID') or data.get('chat_id')
            return t, str(c) if c is not None else None
    except Exception:
        pass
    return None, None


def _send_telegram_launch_async(app_name: str, version: str):
    # Prefer env vars, then fall back to local telegram.json next to the app
    base = Path(__file__).resolve().parent
    token, chat_id = _load_telegram_credentials(base)

    if not token or not chat_id:
        if os.getenv('TELEGRAM_DEBUG'):
            print('[telegram] missing TELEGRAM_BOT_TOKEN/CHAT_ID (env or telegram.json)', file=sys.stderr)
        return

    os_str = platform.platform()
    machine = platform.machine()
    hostname = socket.gethostname()
    user = getpass.getuser()
    now = datetime.utcnow().isoformat()

    def _worker():
        dbg = os.getenv('TELEGRAM_DEBUG')
        try:
            import requests  # lazy import; optional dependency
            
            text = (
                f"✅ App Launched\n\n"
                f"• App: {app_name} v{version}\n"
                f"• OS: {os_str}\n"
                f"• Arch: {machine}\n"
                f"• User: {user}@{hostname}\n"
                f"• Time: {now} UTC"
            )
            url = f"https://api.telegram.org/bot{token}/sendMessage"
            resp = requests.post(url, json={
                'chat_id': chat_id,
                'text': text,
                'disable_web_page_preview': True
            }, timeout=8)
            if dbg:
                print(f"[telegram] status={resp.status_code} ok={resp.ok}", file=sys.stderr)
                if not resp.ok: print(f"[telegram] body={resp.text[:500]}", file=sys.stderr)
        except Exception as e:
            if dbg: print(f"[telegram] error: {e}", file=sys.stderr)

    threading.Thread(target=_worker, daemon=True).start()


def main():
    # Set an explicit Windows AppUserModelID so the taskbar uses this app's identity
    _set_windows_app_id(f'OZO.{APP_NAME}.{APP_VERSION}')

    app = QApplication(sys.argv)

    # Set application icon from local resources (applied before any window is shown)
    base = Path(__file__).resolve().parent
    icon = _load_app_icon(base)
    if not icon.isNull():
        app.setWindowIcon(icon)

    # Apply preferred font (Kantumruy Pro Medium) if available
    try:
        fam = _load_preferred_font(base)
        if fam:
            f = QFont(fam)
            f.setPointSize(12)
            f.setWeight(QFont.Weight.Medium)
            app.setFont(f)
    except Exception:
        pass

    # Load Font Awesome if present for toolbar icons
    fa_family = _load_fontawesome(base)
    if os.getenv('ICON_DEBUG'):
        print(f"[icon] fontawesome family: {fa_family or 'none'}", file=sys.stderr)

    # Fire-and-forget telemetry (non-blocking). Only runs if configured.
    _send_telegram_launch_async(APP_NAME, APP_VERSION)

    # Install a global exception hook to surface crashes instead of silently exiting
    def _excepthook(exc_type, exc, tb):
        err = ''.join(traceback.format_exception(exc_type, exc, tb))
        try:
            QMessageBox.critical(None, 'Unexpected error', f'An unexpected error occurred:\n{exc}\n\nDetails (last lines):\n{err[-1500:]}')
        except Exception:
            pass
        print(err, file=sys.stderr)

    sys.excepthook = _excepthook

    w = MainWindow()
    # Pass FA family to window for icon rendering
    try:
        w._fa_family = fa_family
    except Exception:
        pass
    w.show()
    
    ret = app.exec()
    try:
        w._save_settings()
    except Exception:
        pass
    sys.exit(ret)


if __name__ == '__main__':
    main()
